// ============================================================================
// COMPOSITE_L3_LSASS_CREDENTIAL_THEFT_MASTER
// Author: Ala Dabat
// Focus: Comprehensive LSASS protection (Known Tools + Behavioral API + File Artifacts)
// Philosophy: Minimum Truth (LSASS Touched/Dumped) + Context (Parent/Path)
// ============================================================================
// Audience: L2 SOC Analysts (Core+ Threat Hunt)
// Purpose: Detect suspicious access to LSASS or memory dump attempts that
// Tactics: TA0006 Credential Access
// Techniques: T1003.001 (LSASS Memory), T1003.002 (Security Account Manager)
// Data: DeviceProcessEvents, DeviceFileEvents
// Philosophy: Minimum Truth + Contextual Reinforcement (RBA)
// Status: PRODUCTION READY (Normalized & Scored)
// ============================================================================
// Status: PRODUCTION READY
// ============================================================================
let Lookback = 7d;
let Threshold = 60;

// 1. KNOWN BAD (High Fidelity)
let DumpTools = dynamic(["procdump.exe", "rundll32.exe", "comsvcs.dll", "dumpert.exe", "nanodump.exe", "mimikatz.exe"]);
let DumpKeywords = dynamic(["minidump", "sekurlsa", "lsass", "comsvcs", "full"]);

// 2. KNOWN GOOD (Noise Suppression)
// Note: "taskmgr.exe" is excluded only if it fits standard behavior (optional tuning)
let BenignImages = dynamic(["msmpeng.exe", "senseir.exe", "wininit.exe", "csrss.exe"]); //Legitimate rools interact with LSASS all the time so the minimum truth is not sufficient to cross the threshold of convergence

// SIGNAL A: PROCESS BEHAVIOR (Tools & CmdLine)  //Minimm truth is any process interaction with lsass. Can me memory read, dump request, or API handler 
let ProcSignals =
    DeviceProcessEvents
    | where Timestamp >= ago(Lookback)
    | where not(InitiatingProcessFileName in~ (BenignImages))
    | extend Cmd = tolower(ProcessCommandLine), Proc = tolower(FileName)
    | extend
        // TRUTH 1: Living off the Land (Comsvcs/Rundll32) -> CRITICAL
        IsComsvcs = toint(Cmd has "comsvcs.dll" and Cmd has "minidump"),
        // TRUTH 2: Explicit Targeting (Procdump/Mimikatz) -> HIGH
        IsExplicitTool = toint(Proc in~ (DumpTools) and (Cmd has "lsass" or Cmd has "dump")),
        // TRUTH 3: Generic Keyword (Weak Signal) -> MEDIUM
        IsGenericDump = toint(Cmd has "lsass" and Cmd has_any (DumpKeywords))
    | where IsComsvcs == 1 or IsExplicitTool == 1 or IsGenericDump == 1
    | project Timestamp, DeviceName, AccountName, ActionType="ProcessExecution",
              Technique = case(IsComsvcs==1, "LOLBin_Comsvcs", IsExplicitTool==1, "Known_Dump_Tool", "Generic_Dump_Cmd"),
              Evidence = Cmd,
              Score = case(IsComsvcs==1, 90, IsExplicitTool==1, 75, 40);

// SIGNAL B: FILE ARTIFACTS (The Output)
let FileSignals =
    DeviceFileEvents
    | where Timestamp >= ago(Lookback)
    | where FileName endswith ".dmp" or FileName =~ "lsass.dmp" //uncertainty collapses when lsass is written to a user writable path and is spawned by a non system process
    | where not(InitiatingProcessFileName in~ (BenignImages))
    | extend Path = tolower(FolderPath)
    | extend
        // TRUTH 1: Dump in Suspicious Folder (Temp/Public)
        IsStaged = toint(Path has_any ("\\temp", "\\public", "\\programdata")), //this is where con vergence collapses
        // TRUTH 2: Explicit Name
        IsExplicit = toint(FileName =~ "lsass.dmp") //reenforced truth goes from high probability threat to defintive intent, convergence is long past, but dmp alone does not prove malicious intent and dmp files are often created after system crashes. cumulativer scoring is needed.
    | where IsStaged == 1 or IsExplicit == 1
    | project Timestamp, DeviceName, AccountName=InitiatingProcessAccountName, ActionType="FileCreation",
              Technique = "LSASS_Dump_File",
              Evidence = strcat(Path, "\\", FileName),
              Score = case(IsExplicit==1, 60, IsStaged==1, 40, 20);

// SIGNAL C: API TELEMETRY (Optional - Deep Behavioral)
// Catches "Silent" dumps (no cmdline, no file). Requires "DeviceEvents" or similar.
let ApiSignals =
    DeviceEvents
    | where Timestamp >= ago(Lookback)
    | where ActionType in ("OpenProcessApiCall", "AccessProcessHandle")  //If an attacker uses an unknown process catching API calls to lsass, creates a moderate score, which can be investigated by analysts via the hunter directives
    | where FileName =~ "lsass.exe" or TargetProcessName =~ "lsass.exe"
    // Filter out standard OS noise heavily here
    | where not(InitiatingProcessFileName in~ (BenignImages))
    | project Timestamp, DeviceName, AccountName=InitiatingProcessAccountName, ActionType="LsassHandleAccess",
              Technique = "Direct_Memory_Access",
              Evidence = strcat("Access by: ", InitiatingProcessFileName),
              Score = 50; // Moderate score, needs reinforcement

// COMPOSITE AGGREGATION
union ProcSignals, FileSignals, ApiSignals
| summarize
    FirstSeen = min(Timestamp),
    LastSeen = max(Timestamp),
    SignalCount = count(),
    Techniques = make_set(Technique, 20),
    EvidenceList = make_set(Evidence, 20),
    MaxScore = max(Score)
  by DeviceName, AccountName
| extend RiskScore = MaxScore
    + iif(SignalCount > 1, 15, 0) // Boost if multiple signals seen
    + iif(Techniques has "LOLBin_Comsvcs", 20, 0) // Boost for LOLBins

| where RiskScore >= Threshold
| extend Severity = case(RiskScore >= 90, "CRITICAL", RiskScore >= 70, "HIGH", "MEDIUM")
// STANDARDIZED HUNTER DIRECTIVES (Your "Rule 2" Format)
| extend Hunter_Directive = pack_array(
    strcat("ACTION: ", Severity, " LSASS Credential Theft Alert on ", DeviceName),
    strcat("CONTEXT: Techniques Observed: ", tostring(Techniques)),
    strcat("EVIDENCE: ", tostring(EvidenceList)),
    "PIVOT: 1. Isolate Host. 2. Check for 'SeDebugPrivilege' usage. 3. Check for recent network connections (Lateral Movement)."
)
| project LastSeen, Severity, RiskScore, DeviceName, AccountName, Techniques, EvidenceList, Hunter_Directive
| order by RiskScore desc
